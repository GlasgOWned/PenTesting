$ cat ajax.php
<?php

require_once 'lib/Autoloader.php';
Autoloader::register();
$json = new JsonResult();
$config = new Config();
foreach ($config->getPool() as $key => $server) {
        $client = new Client($server);
        $result = $client->sendCmd($_GET['test']);
        echo $result;
}

// ----------------------------------------------------------------------------

$ cat config.ini
[Redis Server]
host = redis
port = 6379


// ----------------------------------------------------------------------------

$ cat Autoloader.php
<?php
/**
 * Redis Info Autoloader
 *
 * This class used for registering and autoloading libraries
 *
 * @package    Redis Info
 * @author 	   Osman Üngür <osmanungur@gmail.com>
 * @copyright  2010-2011 Osman Üngür
 * @license    http://www.opensource.org/licenses/bsd-license.php BSD License
 * @version    Version @package_version@
 * @since      Class available since Version 1.0.0
 * @link       http://github.com/osmanungur/redis-info
 */
class Autoloader {

    protected static $isRegistered;
    protected static $callback = array('Autoloader', 'load');
    protected static $path;

    public static function register() {
        if (self::isRegistered()) {
            return false;
        }

        self::$isRegistered = spl_autoload_register(self::$callback);

        return self::$isRegistered;
    }

    public static function isRegistered() {
        return self::$isRegistered;
    }

    public static function load($class) {
        $file_path = self::getPath() . DIRECTORY_SEPARATOR . $class . '.php';

        if (!file_exists($file_path)) {
            return false;
        }

        require_once $file_path;
    }

    public static function getPath() {
        if (!self::$path) {
            self::$path = realpath(dirname(__FILE__));
        }

        return self::$path;
    }

}

// ----------------------------------------------------------------------------

$ cat Client.php
<?php

/**
 * Redis Info Client
 *
 * Class used for connecting and fetching information from redis servers
 *
 * @package    Redis Info
 * @author 	   Osman Üngür <osmanungur@gmail.com>
 * @copyright  2010-2011 Osman Üngür
 * @license    http://www.opensource.org/licenses/bsd-license.php BSD License
 * @version    Version @package_version@
 * @since      Class available since Version 1.0.0
 * @link       http://github.com/osmanungur/redis-info
 */
class Client {

    private $socket;
    private $server;

    const COMMAND_INFO = 'INFO';
    const COMMAND_AUTH = 'AUTH';
    const EOL = "\r\n";
    const TIMEOUT = 5;
    const TCP_PREFIX = 'tcp://';
    const SEPERATOR = ':';
    const REPLY_STATUS_BULK = '$';
    const REPLY_STATUS_SUCCESS = '+';
    const REPLY_STATUS_ERROR = '-';
    const REPLY_OK = 'OK';

    public function __construct($server) {
        $this->setServer($server);
        $this->connect();
        if ($this->getServer()->getAuth()) $this->auth();
    }

    public function connect() {
        $connection = @stream_socket_client(self::TCP_PREFIX . $this->getServer()->getHost() . self::SEPERATOR . $this->getServer()->getPort(), $errno, $errstr, self::TIMEOUT);
        if ($connection) {
            $this->setSocket($connection);
            return true;
        } else {
            throw new Exception(sprintf('Cant connect to Redis server %s:%s Error : %s, %s', $this->getServer()->getHost(), $this->getServer()->getPort(), $errno, $errstr), 1);
        }
    }

    public function write($command) {
        $write = fwrite($this->getSocket(), $command . self::EOL);
        if ($write) {
            return true;
        } else {
            throw new Exception('No bytes have been written', 1);
        }
    }

    public function auth() {
        $this->write(self::COMMAND_AUTH . ' ' . $this->getServer()->getAuth());
        $reply = $this->readLine();
        $kind = substr($reply, 0, 1);
        $data = substr($reply, 1);
        if ($kind == self::REPLY_STATUS_SUCCESS && $data == self::REPLY_OK) {
            return true;
        } else {
            throw new Exception(sprintf('Authorization failed to Redis server : %s', $this->getServer()->getName()), 1);
        }
    }

    public function readLine() {
        $line = trim(fgets($this->getSocket()));
        if ($line) {
            return $line;
        } else {
            throw new Exception('Cant read line from socket.', 1);
        }
    }

    public function readBulkReply($length) {
        $response = trim(fread($this->getSocket(), $length));
        if ($response) {
            return $response;
        } else {
            throw new Exception('Cant read reply from socket.', 1);
        }
    }

    public function getInfo() {
        $this->write(self::COMMAND_INFO);
        $reply = $this->readLine();
        $kind = substr($reply, 0, 1);
        $data = substr($reply, 1);
        if ($kind == self::REPLY_STATUS_BULK) {
            return new Result($this->readBulkReply($data));
        } else {
            throw new Exception(sprintf("Redis server returns an unexpected response : %s", substr($data, 4)), 1);
        }
    }

    public function sendCmd($cmd) {
        $this->write($cmd);
        $reply = $this->readLine();
        $kind = substr($reply, 0, 1);
        $data = substr($reply, 1);
        if ($data > 0){
            return $this->readBulkReply($data);
        }
        else{
            return $data;
        }

        /*if ($kind == self::REPLY_STATUS_BULK) {
            return new Result($this->readBulkReply($data));
        } else {
            throw new Exception(sprintf("Redis server returns an unexpected response : %s", substr($data, 4)), 1);
        }*/
    }

    public function getStreamInfo() {
        return new ArrayObject(stream_get_meta_data($this->getSocket()));
    }

    public function getSocket() {
        return $this->socket;
    }

    public function setSocket($socket) {
        $this->socket = $socket;
    }

    public function getServer() {
        return $this->server;
    }

    public function setServer(Server $server) {
        if ($server instanceof Server) {
            $this->server = $server;
        } else {
            throw new Exception("Error Processing Request", 1);
        }
    }

}

// ----------------------------------------------------------------------------

$ cat Config.php

 <?php

/**
 * Config
 *
 * Parses config file and creates iteratable server pool
 *
 * @package    Redis Info
 * @author 	   Osman Üngür <osmanungur@gmail.com>
 * @copyright  2010-2011 Osman Üngür
 * @license    http://www.opensource.org/licenses/bsd-license.php BSD License
 * @version    Version @package_version@
 * @since      Class available since Version 1.0.0
 * @link       http://github.com/osmanungur/redis-info
 */
class Config {
    const SERVER_PROPERTY_HOST = 'host';
    const SERVER_PROPERTY_PORT = 'port';
    const SERVER_PROPERTY_AUTH = 'auth';

    const CONFIG_FILE_PATH = './config.ini';
    const PROCESS_SECTIONS = true;

    private $configuration;
    private $pool;

    public function __construct() {
        $this->setConfiguration();
        $this->setPool();
    }

    public function getConfiguration() {
        return $this->configuration;
    }

    public function setConfiguration() {
        $this->configuration = parse_ini_file(self::CONFIG_FILE_PATH, self::PROCESS_SECTIONS);
    }

    public function getPool() {
        return $this->pool;
    }

    public function setPool() {
        $pool = new Pool();
        foreach ($this->getConfiguration() as $key => $value) {
            $array = new ArrayObject($value);
            $server = new Server();
            $server->setHost($array->offsetGet(self::SERVER_PROPERTY_HOST))
                    ->setPort($array->offsetGet(self::SERVER_PROPERTY_PORT))
                    ->setName($key);
            if ($array->offsetExists(self::SERVER_PROPERTY_AUTH)) {
                $server->setAuth($array->offsetGet(self::SERVER_PROPERTY_AUTH));
            }
            $pool->attach($server);
        }
        $this->pool = $pool;
    }

}

// ----------------------------------------------------------------------------

$ cat JsonResult.php

<?php

/**
 * Redis Info JsonResult
 *
 * Used for creating JavaScript Object Notation formatted output for browsers
 *
 * @package    Redis Info
 * @author 	   Osman Üngür <osmanungur@gmail.com>
 * @copyright  2010-2011 Osman Üngür
 * @license    http://www.opensource.org/licenses/bsd-license.php BSD License
 * @version    Version @package_version@
 * @since      Class available since Version 1.0.0
 * @link       http://github.com/osmanungur/redis-info
 */
class JsonResult extends ArrayObject {
    const RESULT_SUCCESS = 'success';
    const RESULT_ERROR = 'error';

    const KEY_RESULT = 'result';
    const KEY_SERVER = 'server';
    const KEY_MESSAGE = 'message';
    const KEY_STATISTICS = 'statistics';
    const KEY_DATABASES = 'databases';

    public function appendResponse(Server $server, $statistics, $databases) {
        $this->append( new ArrayObject(array(self::KEY_RESULT => self::RESULT_SUCCESS, self::KEY_SERVER => $server, self::KEY_STATISTICS => $statistics, self::KEY_DATABASES => $databases)) );
    }

    public function appendError(Server $server, $errstr) {
        $this->append( new ArrayObject(array(self::KEY_RESULT => self::RESULT_ERROR, self::KEY_SERVER => $server, self::KEY_MESSAGE => $errstr)) );
    }

}

// ----------------------------------------------------------------------------

$ cat Pool.php

<?php

/**
 * Redis Info Pool
 *
 * Class used for storing and retrieving redis server objects
 *
 * @package    Redis Info
 * @author 	   Osman Üngür <osmanungur@gmail.com>
 * @copyright  2010-2011 Osman Üngür
 * @license    http://www.opensource.org/licenses/bsd-license.php BSD License
 * @version    Version @package_version@
 * @since      Class available since Version 1.0.0
 * @link       http://github.com/osmanungur/redis-info
 */
class Pool extends SplObjectStorage {

}

// ----------------------------------------------------------------------------

$ cat Result.php

<?php

/**
 * Redis Info Result
 *
 * Parser for redis info command output
 *
 * @package    Redis Info
 * @author 	   Osman Üngür <osmanungur@gmail.com>
 * @copyright  2010-2011 Osman Üngür
 * @license    http://www.opensource.org/licenses/bsd-license.php BSD License
 * @version    Version @package_version@
 * @since      Class available since Version 1.0.0
 * @link       http://github.com/osmanungur/redis-info
 */
class Result {
    const DB_KEY = 'db';
    const DB_PATTERN = '/keys=(?<totalKey>\d+),expires=(?<willExpire>\d+)/';
    private $response;
    private $statistics;
    private $databases;
    private $knownInfoPatterns = array(
        'redis_version',
        'redis_git_sha1',
        'redis_git_dirty',
        'arch_bits',
        'multiplexing_api',
        'process_id',
        'uptime_in_seconds',
        'uptime_in_days',
        'connected_clients',
        'connected_slaves',
        'blocked_clients',
        'used_memory',
        'used_memory_human',
        'changes_since_last_save',
        'bgsave_in_progress',
        'last_save_time',
        'bgrewriteaof_in_progress',
        'total_connections_received',
        'total_commands_processed',
        'expired_keys',
        'hash_max_zipmap_entries',
        'hash_max_zipmap_value',
        'pubsub_channels',
        'pubsub_patterns',
        'vm_enabled',
        'role');

    public function __construct($response) {
        $this->setResponse($response);
        $this->setStatistics();
        $this->setDatabases();
    }

    public function getResponse() {
        return $this->response;
    }

    public function setResponse($response) {
        $lines = new ArrayObject(explode(Client::EOL, $response));
        $this->response = $lines;
    }

    public function getStatistics() {
        return $this->statistics;
    }

    public function setStatistics() {
        $statistics = new ArrayObject();
        foreach ($this->getResponse() as $value) {
            $line = new ArrayObject(explode(':', $value, 2));
            if (in_array($line->offsetGet(0), $this->getKnownInfoPatterns())) {
                $statistics->offsetSet($line->offsetGet(0), $line->offsetGet(1));
            }
        }
        $this->statistics = $statistics;
    }

    public function getDatabases() {
        return $this->databases;
    }

    public function setDatabases() {
        $databases = new ArrayObject();
        foreach ($this->getResponse() as $value) {
            $line = new ArrayObject(explode(':', $value, 2));
            if (strpos($line->offsetGet(0), self::DB_KEY) !== FALSE) {
                preg_match(self::DB_PATTERN, $line->offsetGet(1), $matches);
                $databases->offsetSet($line->offsetGet(0), new ArrayObject($matches));
            }
        }
        $this->databases = $databases;
    }

    public function getKnownInfoPatterns() {
        return $this->knownInfoPatterns;
    }

}

// ----------------------------------------------------------------------------

$ cat Server.php
<?php

/**
 * Redis Info Server
 *
 * Object for representing a redis server
 *
 * @package    Redis Info
 * @author 	   Osman Üngür <osmanungur@gmail.com>
 * @copyright  2010-2011 Osman Üngür
 * @license    http://www.opensource.org/licenses/bsd-license.php BSD License
 * @version    Version @package_version@
 * @since      Class available since Version 1.0.0
 * @link       http://github.com/osmanungur/redis-info
 */
class Server {

    public $host;
    public $port;
    private $auth;
    public $name;

    public function getHost() {
        return $this->host;
    }

    public function setHost($host) {
        $this->host = $host;
        return $this;
    }

    public function getPort() {
        return $this->port;
    }

    public function setPort($port) {
        $this->port = $port;
        return $this;
    }

    public function getAuth() {
        return $this->auth;
    }

    public function setAuth($auth) {
        $this->auth = $auth;
        return $this;
    }

    public function getName() {
        return $this->name;
    }

    public function setName($name) {
        $this->name = $name;
        return $this;
    }

    public function getHash() {
        return md5($this->getName() . $this->getPort());
    }

}
